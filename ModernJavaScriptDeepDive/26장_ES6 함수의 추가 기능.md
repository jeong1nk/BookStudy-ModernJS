# 26.1. 함수의 구분
- ES6 이전의 모든 함수는 이란 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출할 수 있다.(callable이면서 constructor)
- 이처럼 ES6 이전의 모든 함수는 사용 목적에 따라 명확한 구분이 없으므로 호출 방식에 ㅊ특별한 제약이 없고 생성자 함수로 호출되지 않아도 프로토타입 객체를 생성한다.
- 이는 혼란스럽고 실수를 유발할 수 있다.
- 이러한 문제를 해결하기 위해 ES5에서는 함수를 사용 목적에 따라 세가지 종류로 명확히 구분했다.

| ES6 함수의 구분 | constructor | prototype | super | arguments |
|----------------|--------------|-------------|--------|-------------|
| 일반 함수 (Normal) | ○ | ○ | × | ○ |
| 메서드 (Method) | × | × | ○ | × |
| 화살표 함수 (Arrow) | × | × | × | × |

# 26.2. 메서드
- ES6 사양에서 메서드는 메서드 축약 표현으로 정의된 함수만을 의미한다.
```javascript
const obj = {
  x: 1,
  // foo는 메서드이다.
  foo() { return this.x; },
  // bar에 바인딩된 함수는 메서드가 아닌 일반 함수이다.
  bar: function() { return this.x; }
};

console.log(obj.foo()); // 1
console.log(obj.bar()); // 1
```
- ES6  사양에서 정의한 메서드는 인스턴스를 생성할 수 없는 non-constructor다. 따라서 생성자 함수로서 호출할 수 없다.
- 인스턴스를 생성할 수 없으므로 prototype 프로퍼티가 없고 프로토타입도 생성하지 않는다.
```javascript
new obj.foo(); // -> TypeError: obj.foo is not a constructor
new obj.bar(); // -> bar {}

// obj.foo는 constructor가 아닌 ES6 메서드이므로 prototype 프로퍼티가 없다.
obj.foo.hasOwnProperty('prototype'); // -> false

// obj.bar는 constructor인 일반 함수이므로 prototype 프로퍼티가 있다.
obj.bar.hasOwnProperty('prototype'); // -> true
```
- ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부 슬롯 [[HomeObject]]를 갖는다. 그러므로 내부 슬롯 [[HomeObject]]를 사용해 수퍼 클래스를 차조하는 super 키워들르 사용할 수 있다.

# 26.3. 화살표 함수
### 26.3.1. 화살표 함수 정의
