# 21.1. 자바스크립트 객체의 분류
- 자바스크립트 객체는 크게 3가지로 분류할 수 있다.

**1. 표준 빌트인 객체**
  - ECMAScript 사양에 정의된 객체, 애플리케이션 전역의 공통 기능을 제공한다.
  - ECMAScript 사양에 정의된객체이므로 자바스크립트 실행 환경과 관계없이 언제나 사용할 수 있다.
  - 표준 빌트인 객체는 전역 객체의 프로퍼티로서 제공되며, 따라서 별도의 선언 없이 전역 변수처럼 언제나 참조할 수 있다.

**2. 호스트 객체**
  - ECMAScript 사양에 정의되지는 않았지만, 자바스크립트 실행환경에서 제공하는 객체
  - 브라우저 환경에서는 클라이언트 사이드 Web API를, Node.js 환경에서는 Node.js 고유의 API를 호스트 객체로 제공한다.

**3. 사용자 정의 객체**
  - 사용자가 직접 정의한 객체

# 21.2. 표준 빌트인 객체 
- 자바스크립트는 Object, String, Number, Boolean, Symbol, Date, Error 등 40여개의 표준 빌트인 객체를 제공한다.
- **Math, Reflect, JSON을 제외한 표준 빌트인 객체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체다.**
- 생성자 함수 객체인 표준 빌트인 객체는 프로토타입 메서드와 정적 메서드를 제공하고, 생성자 함수 객체가 아닌 표준 빌트인 객체는 정적 메서드만 제공한다.
```javascript
// String 생성자 함수에 의한 String 객체 생성
const strObj = new String('Lee'); // String {"Lee"}

// String 생성자 함수를 통해 생성한 strObj 객체의 프로토타입은 String.prototype이다.
console.log(Object.getPrototypeOf(strObj) === String.prototype); // true
```
- 생성자 함수인 표준 빌트인 객체가 생성한 인스턴스의 프로토타입은 표준 빌트인 객체의 prototype 프로퍼티에 바인딩된 객체다.
- 표준 빌트인 객체의 prototype 프로퍼티에 바인딩 된 객체(예제의 String.prototype)는 다양한 빌트인 프로토타입 메서드를 제공하며, 표준 빌트인 객체는 인스턴스 없이도 호출 가능한 빌트인 정적 메서드를 제공한다.
```javascript
// Number 생성자 함수에 의한 Number 객체 생성
const numObj = new Number(1.5); // Number {1.5}

// toFixed는 Number.prototype의 프로토타입 메서드다.
// Number.prototype.toFixed는 소수점 자리를 반올림하여 문자열로 반환한다.
console.log(numObj.toFixed()); // 2

// isInteger는 Number의 정적 메서드다.
// Number.isInteger는 인수가 정수(integer)인지 검사하여 그 결과를 Boolean으로 반환한다.
console.log(Number.isInteger(0.5)); // false
```

# 21.3. 원시값과 래퍼 객체
- 원시값을 객체처럼 사용하면 암묵적으로 연관된 객체를 생성해 생성된 객체로 프로퍼티에 접근하거나 메서드를 호출하고 다시 원시값으로 되돌린다. 이때 생성되는 임시 객체를 래퍼 객체라고 한다. 
- 🏷️**래퍼 객체: 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체**
```javascript
const str = 'hi';

// 원시 타입인 문자열이 래퍼 객체인 String 인스턴스로 변환된다.
console.log(str.length); // 2
console.log(str.toUpperCase()); // HI

// 래퍼 객체로 프로퍼티에 접근하거나 메서드를 호출한 후, 다시 원시값으로 되돌린다.
console.log(typeof str); // string
```
- 이때 문자열 래퍼 객체인 Sring 생성자 함수의 인스턴스는 String.prototype의 메서드를 상속받아 사용할 수 있다.
- 그 후 래퍼 객체의 처리가 종료되면 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된 원시값을 갖도록 되돌리고 래퍼 객체는 가비지 컬렉션의 대상이 된다.
```javascript
// ① 식별자 str은 문자열을 값으로 가지고 있다.
const str = 'hello';

// ② 식별자 str은 암묵적으로 생성된 래퍼 객체를 가리킨다.
// 식별자 str의 값 'hello'는 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된다.
// 래퍼 객체에 name 프로퍼티가 동적 추가된다.
str.name = 'Lee';

// ③ 식별자 str은 다시 원래의 문자열, 즉 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된 원시값을 갖는다.
// 이때 ②에서 생성된 래퍼 객체는 아무도 참조하지 않는 상태이므로 가비지 컬렉션의 대상이 된다.

// ④ 식별자 str은 새롭게 암묵적으로 생성된(②에서 생성된 래퍼 객체와는 다른) 래퍼 객체를 가리킨다.
// 새롭게 생성된 래퍼 객체에는 name 프로퍼티가 존재하지 않는다.
console.log(str.name); // undefined

// ⑤ 식별자 str은 다시 원래의 문자열, 즉 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된 원시값을 갖는다.
// 이때 ④에서 생성된 래퍼 객체는 아무도 참조하지 않는 상태이므로 가비지 컬렉션의 대상이 된다.
console.log(typeof str, str);
```
- 숫자 값이나 불리언 값도 마찬가지로 적용된다.(불리언 값으로 메서드를 호출하는 경우는 많이 없기는 하다.)
- **따라서 String, Number, Boolean 생성자 함수를 new 연산자와 함께 호출하여 문자열, 숫자, 불리언 인스턴스를 생성할 필요가 없으며 권장하지도 않는다.**
- 문자열, 숫자, 불리언, 심벌 이외의 원시값, 즉 null과 undefined는 래퍼 객체를 생성하지 않으므로, 두 값을 객체처럼 사용하면 에러가 발생한다.

# 21.4. 전역 객체

- 
