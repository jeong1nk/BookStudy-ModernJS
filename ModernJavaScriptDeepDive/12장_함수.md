# 12.1. 함수란?⭐가장 중요⭐
- **🏷️함수: 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것**
- 함수 내부로 입력을 전달받는 변수를 **매개변수**, 입력을 **인수**, 출력을 **반환값**이라 한다.
```javascript
// 함수 호출
var result = add(2, 5);

// 함수 add에 인수 2, 5를 전달하면서 호출하면 반환값 7을 반환한다.
console.log(result); // 7
```
- 함수는 **함수 정의**를 통해 생성한다.
- 선언 만으로 함수가 실행되는 것은 아니며, 함수를 호출해야한다. 함수가 호출되고 나면 함수 안의 문이 일괄적으로 실행된 뒤, 반환값을 반환한다.

# 12.2. 함수를 사용하는 이유
- 함수는 몇 번이든 재사용이 가능하다. 이는 코드의 중복을 억제하고 **재사용성을 높이므로, 유지보수 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높인다.**
- 함수는 **객체 타입의 값**이므로 **이름(식별자)** 을 붙일 수 있다. 적절한 함수이름은 내부 코드를 이해하지 않고도 함수의 역할을 파악할 수 있도록 도와 **코드의 가독성을 향상** 시킨다.

# 12.3. 함수 리터럴
- 함수는 **객체 타입의 값**이므로, **함수 리터럴로 생성할 수 있다.**
- **🏷️리터럴: 값을 생성하기 위한 표기법**
- **🏷️함수 리터럴: 변수에 함수 자체를 값으로 할당하는 함수 표현식**
```javascript
// 변수에 함수 리터럴을 할당 -> 함수 리터럴(function 키워드와 ()로 감싼 함수 몸체와 함께 정의)
var f = function add(x, y) {
  return x + y;
};
```
- **함수 이름은 생략할 수 있다.** 이름이 있는 함수를 **기명함수**, 이름이 없는 함수를 **무명/익명 함수**라고 한다.
- **매개변수 목록은 순서가 의미 있다.** 지정한 인수가 **순서대로 할당**된다.
- 함수 몸체는 하나의 실행단위로 코드 블록으로 함수 호출에 의해 실행된다.
- **일반 객체는 호출할 수 없지만, 함수는 호출할 수 있는 객체이다.**

# 12.4. 함수 정의
- **함수를 선언하는 방법 4가지**
> 1. 함수 선언문
> 2. 함수 표현식
> 3. Function 생성자 함수
> 4. 화살표 함수

### 12.4.1. 함수 선언문
```javascript
// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 참조
// console.dir은 console.log와는 달리 함수 객체의 프로퍼티까지 출력한다.
// 단, Node.js 환경에서는 console.log와 같은 결과가 출력된다.
console.dir(add); // ƒ add(x, y)

// 함수 호출
console.log(add(2, 5)); // 7
```
- **함수 리터럴은 이름을 생략할 수 있으나 함수 선언문은 함수 이름을 생략할 수 없다.**
- **함수 선언문은 표현식이 아닌 문이다. 그러므로 피연산자로 사용할 수 없다.**

```javascript
// 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석된다.
// 함수 선언문에서는 함수 이름을 생략할 수 없다.
function foo() { console.log('foo'); }
foo(); // foo

// 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석된다.
// 함수 리터럴에서는 함수 이름을 생략할 수 있다.
(function bar() { console.log('bar'); });
bar(); // ReferenceError: bar is not defined
```
- 기명(이름있는) 함수 리터럴은 **중의적인 코드**로, 문맥에 따라 해석이 달라진다.
- 함수 리터럴을 피연산자로 사용하지 않는 경우(단독으로 사용하는 경우)에는 함수 선언문으로, 함수 리터럴이 값으로 평가되어야 하는 문맥에서는 함수 리터럴 표현식으로 해석한다.

- 함수 선언문과 함수 리터럴 표현식은 함수 객체를 생성한다는 점에서 동일하지만 호출에 차이가 있다.
- 위의 예제에서도 함수 선언문으로 생성된 foo는 호출할 수 있으나, 함수 리터럴 표현식으로 생성된 bar는 호출할 수 없다.
<br />

- 자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.
- 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.
  
```javascript
var add = function add(x, y) {
  return x + y;
};

console.log(add(2, 5)); // 7
```
- 위의 예제에서 함수를 호출할 때 사용하는 것은 함수 이름 add가 아니라 자바스크립트 엔진이 암묵적으로 생성한 식별자 add이다.

### 12.4.2. 함수 표현식
- 함수처럼 값의 성질을 갖는 객체를 **일급 객체**라고 한다. 이는 **함수를 값처럼 자유롭게 사용할 수 있다는 의미이다.**
- 일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 이러한 방식을 **함수 표현식**이라고 한다.
```javascript
// 함수 표현식
var add = function (x, y) {
  return x + y;
};

console.log(add(2, 5)); // 7
```
- 함수 리터럴의 함수 이름은 생략할 수 있다. 이를 익명 함수라고 한다.
<br />
```javascript
// 기명 함수 표현식
var add = function foo (x, y) {
  return x + y;
};

// 함수 객체를 가리키는 식별자로 호출
console.log(add(2, 5)); // 7

// 함수 이름으로 호출하면 ReferenceError가 발생한다.
// 함수 이름은 함수 몸체 내부에서만 유효한 식별자다.
consol현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.
- 따라서 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다.
### 12.4.4. 화살표 함수
### 12.4.5.

# 12.5. 함수 호출
### 12.5.1.
### 12.5.2.
### 12.5.3.
### 12.5.4.

# 12.6. 참조에 의한 전달과 외부 상태의 변경

# 12.7.
### 12.7.1.
### 12.7.2.
### 12.7.3.
### 12.7.4.
### 12.7.5.
